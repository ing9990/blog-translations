```
original: https://medium.com/@agayevrauf/lock-types-in-kotlin-14c81a670028
translator: @ing9990
notes: |
  - 이 글은 원문의 기술적 의도를 최대한 유지하며 번역되었습니다.
```

--- 



번역 기준 단어

| 원문             | 해석    |
|----------------|-------|
| Race Condition | 경쟁 상태 |

## 서론

여러 스레드가 동시에 공유 자원에 접근하는 **동시성 프로그래밍**에서는, 경쟁 상태 와 **데이터 불일치**를 방지하기 위해 **스레드 안정성**을
확보하는 것이 중요합니다. 현대의 JVM 기반 프로그래밍 언어는 동기적으로 공유된 자원에 접근하도록 락 종류를 제공합니다. 이 글에선 코틀린에서 일반적으로 사용되는 락 타입을
알아보고 용도를 알아보기 위해 예시 코드 제공합니다.

### Mutex Lock

---

**뮤텍스(Mutual Exclusion) 락**은 오직 하나의 스레드만 한번에 공유된 자원에 접근할 수 있도록 하는 코틀린의 기본적인 락 타입입니다. 뮤텍스는 2개의 중요한
메서드를 제공합니다. `lock()`과 `unlock()`.

스레드가 `lock()`을 호출하면 락을 취득합니다. 그리고 다른 스레드에서 락 취득을 시도하면 스레드가 `unlock()`을 사용해 락이 풀려날 때까지 취득에 실패할 것입니다.
이것은 공유된 자원에 대한 **독점적인 접근을 보장**하고, 데이터의 경쟁 상태와 불일치를 막습니다. 아래는 Mutex의 예시입니다.

```java
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex

val mutex = Mutex()

suspend fun

accessSharedResource() {
    mutex.lock()
    try {
        // 공유된 자원에 안전하게 접근함
    } finally {
        mutex.unlock()
    }

}
```

### ReadWrite Lock

---

ReadWriteLock는 **읽기 작업에 대해 공유된 자원에 대한 동시 접근을 허용**합니다. 그러나 **쓰기 작업에 대해서는 독점적인 접근**을 허용합니다. 여러 스레드는 읽기
락을 동시에 취득할 수 있습니다. 이 락 타입은 공유된 자원의 수정 빈도에 비해서 읽기 빈도가 더 많을 때 어울립니다. `ReadWriteLock`의 구현으로 코틀린은
`ReentrantReadWriteLock` 클래스를 제공합니다. 아래는 예시입니다.

```java
import java.util.concurrent.locks.ReentrantReadWriteLock

val readWriteLock = ReentrantReadWriteLock()

fun readSharedResource() {
    readWriteLock.readLock().lock()
    try {
        // 공유된 자원 읽기
    } finally {
        readWriteLock.readLock().unlock()
    }
}

fun writeSharedResource() {
    readWriteLock.writeLock().lock()
    try {
        // 공유된 자원 쓰기
    } finally {
        readWriteLock.writeLock().unlock()
    }
}
```

### Semaphore

---

세마포어는 ~~