```text
original: https://hazelcast.com/foundations/distributed-computing/distributed-transaction
translator: @ing9990
notes: |
  - 이 글은 원문의 기술적 의도를 최대한 유지하며 번역되었습니다.
```

---

# 분산 트랜잭션

분산 트랜잭션은 두개 이상의 Repository를 사용한 작업의 집합이다. 주로 네트워크로 연결된 두개 이상의 저장소가 연결된다. 혹은 하나의 서버에서도 여러 데이터베이스에 걸쳐질
수도 있다.

- 저장소는 주로 데이터베이스 이지만, 데이터베이스에 한정된 것은 아님.

### 원자성

- 성공적인 분산 트랜잭션은 두 개 중 하나의 책임을 가집니다. (Atomicity)
    1. 모든 작업은 성공적으로 완료되어야 합니다.
    2. 시스템에 아무 작업도 수행되지 않아야 합니다.

- 후자의 경우, 만약 일부 작업이 실패가 발생하기 전에 완료되었다면 **그 작업은 되돌려져서 결국 완료된 작업이 아무것도 없도록 보장**해야 합니다. (Rollback)

이러한 유형의 작업은 데이터의 무결성을 보장하는 데이터베이스의 ACID 원칙을 준수합니다.

ACID는 일반적으로 하나의 싱글 데이터베이스 서버만을 보장합니다. 그러나 분산 트랜잭션들은 그 것을 여러 데이터베이스에 거쳐 보장되도록 보장합니다.

Two-pahse commit(2PC)로 알려진 이 작업은 분산 트랜잭션의 한 형태입니다.

- XA 트랜잭션은 2PC를 구현한 XA 프로토콜을 사용하는 트랜잭션입니다.

### 분산 트랜잭션의 동작 방식

- 분산 트랜잭션은 일반적인 데이터베이스 트랜잭션과 동일한 처리 완료 요구사항을 갖습니다.

    ```json
    Distributed transactions have the same processing completion requirements as regular database transaction.
    ```

- 그러나 분산 트랜잭션은 여러 리소스에 걸쳐 관리되어야 하므로, 데이터베이스 개발자에게 구현이 더 복잡해집니다. 이러한 여러 리소스는 더 많은 실패 지점을 만들어냅니다. 예를
  들어 데이터베이스 소프트웨어와 같은 별도의 소프트웨어 시스템, 추가적인 하드웨어 서버, 그리고 네트워크 장애 등이 그 예시입니다.
- 이것은 분산 트랜잭션이 실패에 민감하도록 만듭니다 그리고 이것은 데이터 무결성을 위해 안전장치가 도입되어야 하는 이유입니다.

분산 트랜잭션이 발생하려면, **트랜잭션 매니저**가 리소스를 조율해야 합니다.

트랜잭션 매니저는 트랜잭션의 일부 업데이트되는 데이터 저장소가 될수도 있고, 조율만을 담당하는 완전히 독립된 리소스일 수도 있습니다.

트랜잭션 매니저는 성공 트랜잭션을 커밋할지 혹은 실패한 트랜잭션을 롤백할지 여부를 결정합니다. 후자의 경우에는 데이터베이스를 수정하지 않습니다.

1. 어플리케이션은 분산 트랜잭션을 각 리소스에서 트랜잭션 매니저에게 요청합니다.
2. 트랜잭션 매니저는 각 리소스로 분기합니다. 각 리소스는 분산 트랜잭션의 참가를 돕는 리소스 매니저를 가집니다.
3. 분산 트랜잭션은 실패 시 직면하는 부분적 업데이트를 방지하기 위해 `two phase`로 트랜잭션을 완료합니다.
4. `first phase`는 커밋 의도를 확인하는 것을 수반합니다. 즉 커밋 준비 단계(`prepare-to-commit`)로 구성됩니다.
5. 모든 리소스의 커밋 의도가 확인되면 최종 커밋을 요청합니다.
6. 그리고 트랜잭션이 완료됩니댜.

우리는 분산 트랜잭션 도중 실패가 발생했을 때 어떤 일이 일어나는지를 보여주는 기본적인 예시를 살펴볼 수 있습니다.

하나 혹은 그 이상의 리소스가 `prepare-to-commit` 단계에서 이용 불가능 상태가 되었을 때 어떻게 될까?

`request timeout`이 발생했을 때, 트랜잭션 매니저는 각 리소스에게 `prepare-to-commit` 상태를 삭제하는 명령을 내리고 모든 데이터는 다시 그들의 처음
상태로 리셋됩니다.

대신 어느 리소스던 `commit` 단계에서 이용 불가능 상태가 되면, 트랜잭션 매니저는 트랜잭션의 일부를 성공적으로 커밋한 다른 리소스에게 `undo` 혹은 `rollback`
명령을 내립니다. 그리고 다시 데이터는 원래 상태로 돌아가게됩니다.

트랜잭션을 재시도해 작업을 완료하는 것은 이제 어플리케이션의 역할입니다.

### 분산 트랜잭션이 필요한 이유

분산 트랜잭션들은 여러 데이터베이스에 걸쳐 관련된 데이터를 빠르게 업데이트 할 때 필요합니다.

예를 들어, 당신이 사용자의 정보를 추적하고 (이메일 주소를 업데이트 하는 것과 같은) 보편적 업데이트를 만드는 것이 필요한 시스템을 가지고 있다면 분산 트랜잭션은 모든 레코드가
업데이트 되는 것을 보장합니다.

그리고 만약 실패한 경우, 데이터는 원래의 상태로 리셋됩니다. 그리고 재시도는 처음 요청한 어플리케이션의 몫입니다.

```text
and it is up to the originating application to resubmit the transaction.
```

### 스트리밍 데이터를 위한 분산 트랜잭션

오늘 날 분산 트랜잭션은 데이터 스트리밍 환경에서 들어오는 데이터의 양 때문에 특히 중요합니다.

```text
Distributed transactions are especially critical today in data streaming environment because of the volume of incoming data.
```

리로스 중 하나의 단기적인 실패일지라도 잠재적으로 대규모의 데이터 손실을 발생시킬 수 있습니다.

정교한 스트리밍 처리 엔진은 “`exactly-once`” 처리 방식을 지지합니다. 그 시스템 안에서 분산 트랜잭션은 `datasource`로 부터의 읽기와 처리, 그리고
목적지로의 쓰기를 보장합니다.